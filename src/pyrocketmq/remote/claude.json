{
  "module_name": "remote",
  "purpose": "提供与RocketMQ服务器进行远程通信的功能，支持同步和异步两种模式，包括连接管理、RPC调用、单向消息发送、请求处理和连接池管理",
  "functions": [
    {
      "name": "Remote.__init__",
      "parameters": "transport_cfg: TransportConfig, config: RemoteConfig",
      "return_value": "None",
      "role": "初始化同步远程通信实例，创建传输层、配置等待者管理、opaque生成器和请求处理器映射"
    },
    {
      "name": "Remote.connect",
      "parameters": "无",
      "return_value": "None",
      "role": "建立与服务器的连接，启动清理线程和消息接收线程"
    },
    {
      "name": "Remote.close",
      "parameters": "无",
      "return_value": "None",
      "role": "关闭连接，停止所有后台线程，清理等待者和资源"
    },
    {
      "name": "Remote.rpc",
      "parameters": "command: RemotingCommand, timeout: float | None = None",
      "return_value": "RemotingCommand",
      "role": "发送RPC请求并等待响应，支持超时控制"
    },
    {
      "name": "Remote.oneway",
      "parameters": "command: RemotingCommand",
      "return_value": "None",
      "role": "发送单向消息，不等待响应"
    },
    {
      "name": "Remote.register_request_processor",
      "parameters": "code: int, processor: ClientRequestFunc",
      "return_value": "None",
      "role": "注册请求处理器，用于处理服务器主动发起的请求"
    },
    {
      "name": "AsyncRemote.__init__",
      "parameters": "transport_cfg: TransportConfig, config: RemoteConfig",
      "return_value": "None",
      "role": "初始化异步远程通信实例，使用异步锁和事件管理并发"
    },
    {
      "name": "AsyncRemote.connect",
      "parameters": "无",
      "return_value": "Coroutine[None]",
      "role": "异步建立连接，启动清理任务和消息接收任务"
    },
    {
      "name": "AsyncRemote.rpc",
      "parameters": "command: RemotingCommand, timeout: float | None = None",
      "return_value": "Coroutine[RemotingCommand]",
      "role": "异步发送RPC请求并等待响应"
    },
    {
      "name": "AsyncRemote.oneway",
      "parameters": "command: RemotingCommand",
      "return_value": "Coroutine[None]",
      "role": "异步发送单向消息"
    },
    {
      "name": "ConnectionPool.__init__",
      "parameters": "address: str | tuple[str, int], pool_size: int = 1, remote_config: RemoteConfig | None = None, transport_config: TransportConfig | None = None",
      "return_value": "None",
      "role": "初始化同步连接池，管理多个Remote实例"
    },
    {
      "name": "ConnectionPool.get_connection",
      "parameters": "timeout: float | None = None, usage: str | None = None",
      "return_value": "Generator[Remote, None, None]",
      "role": "上下文管理器，从池中获取连接并在使用后自动归还"
    },
    {
      "name": "AsyncConnectionPool.get_connection",
      "parameters": "timeout: float | None = None, usage: str | None = None",
      "return_value": "AsyncGenerator[AsyncRemote, None]",
      "role": "异步上下文管理器，从池中获取异步连接"
    },
    {
      "name": "RemoteFactory.create_sync_remote",
      "parameters": "address: str | tuple[str, int], remote_config: RemoteConfig | None = None, transport_config: TransportConfig | None = None",
      "return_value": "Remote",
      "role": "工厂方法创建同步远程通信实例"
    },
    {
      "name": "RemoteFactory.create_async_remote",
      "parameters": "address: str | tuple[str, int], remote_config: RemoteConfig | None = None, transport_config: TransportConfig | None = None",
      "return_value": "AsyncRemote",
      "role": "工厂方法创建异步远程通信实例"
    }
  ],
  "dependencies": {
    "internal": [
      "pyrocketmq.logging",
      "pyrocketmq.model",
      "pyrocketmq.transport.config",
      "pyrocketmq.transport.tcp"
    ],
    "external": [
      "threading",
      "asyncio",
      "time",
      "logging",
      "random",
      "os",
      "dataclasses",
      "typing",
      "contextlib",
      "collections.abc"
    ]
  },
  "call_flow": {
    "同步RPC调用流程": [
      "1. Remote.rpc() 接收命令和超时参数",
      "2. 生成唯一opaque值并设置到命令",
      "3. 创建Event并注册到等待者映射",
      "4. 序列化命令并通过传输层发送",
      "5. 等待Event触发或超时",
      "6. 接收线程收到响应后匹配opaque并设置等待者",
      "7. 返回响应或抛出超时异常"
    ],
    "异步RPC调用流程": [
      "1. AsyncRemote.rpc() 接收命令和超时参数",
      "2. 异步生成唯一opaque值",
      "3. 创建asyncio.Event并注册到等待者映射",
      "4. 序列化命令并异步发送",
      "5. 使用asyncio.wait_for等待响应",
      "6. 接收协程收到响应后匹配opaque并设置等待者",
      "7. 返回响应或抛出超时异常"
    ],
    "连接池获取流程": [
      "1. get_connection() 被调用",
      "2. 等待从池中提取可用连接",
      "3. 验证连接有效性（检查是否过期或断开）",
      "4. 如无效则重建连接",
      "5. 更新最后使用时间",
      "6. yield连接给调用者",
      "7. 使用结束后自动归还连接到池中"
    ]
  },
  "error_handling": {
    "策略": "分层错误处理机制，包含连接错误、超时错误、协议错误等",
    "错误类型": {
      "ConnectionError": "连接相关错误，包括连接失败和连接断开",
      "RpcTimeoutError": "RPC调用超时错误",
      "SerializationError": "序列化/反序列化错误",
      "ProtocolError": "协议错误，如无效响应格式",
      "ResourceExhaustedError": "资源耗尽错误，如超过最大等待者数量",
      "ConfigurationError": "配置参数错误",
      "TransportError": "传输层错误",
      "WaiterTimeoutError": "等待者超时错误",
      "MaxWaitersExceededError": "最大等待者数量超出错误",
      "InvalidCommandError": "无效命令错误",
      "ConnectionClosedError": "连接已关闭错误"
    },
    "处理机制": {
      "错误分类": "is_connection_error()、is_timeout_error()、is_retryable_error()、is_fatal_error() 等辅助函数判断错误类型",
      "资源清理": "发生错误时自动清理等待者、关闭连接、停止后台线程",
      "连接重建": "连接池中的无效连接会被自动检测并重建",
      "超时处理": "使用Event和asyncio.Event实现超时控制，超时后自动清理资源",
      "异常传播": "保留原始异常链，便于问题追踪",
      "日志记录": "详细记录错误信息和上下文，便于排查问题"
    },
    "恢复策略": {
      "连接断开": "自动重连机制，在接收线程中检测并等待重连",
      "等待者过期": "定期清理超时的等待者，防止内存泄漏",
      "连接过期": "基于最大存活时间自动淘汰过期连接",
      "池耗尽": "等待机制，超时后抛出异常而不是阻塞无限期"
    }
  }
}
